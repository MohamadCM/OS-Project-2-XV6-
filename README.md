# OS Project 2

Operating systems final course project

### Please refer to Report.pdf

---

# پروژه دوم درس سیستم های عامل

### دکتر نستوه طاهری جوان

### نویسندگان:

### غزل صادقیان

### محمدمهدی ناصری

### دانشکده مهندسی کامپیوتر، دانشگاه صنعتی اميرکبير

### ٩ دی ١٣٩٨


#### ١ سوال اول

## ١ سوال اول

### (Ticket lock)١. ١ پیاده سازی قفل بلیت

می شود که یک پیادهreleaseوacquireقفل گذاری در هسته xv۶ توسط دو سری تابع صورت می گيرد. دسته اول شامل توابع
وقفه را نیز غيرفعال٢شده و در حين اجرای ناحیه بحرانی١هستند. این قفل ها منجر به انتظار مشغولspin locksسازی ساده از
بوده که مشکل انتظار مشغول را حل نموده و امکان تعامل میانreleasesleepوacquiresleepمی کنند. دسته دوم شامل توابع
پردازه ها را نیز فراهم میکنند. تفاوت اصلی توابع این دسته نسبت به دسته قبل این است که در صورت عدم امکان در اختیار گرفتن
قفل، از تلاش دست کشیده و پردازنده را رها میکنند. قفل بلیت نوعی قفل است که در آن به هر پردازه ای که می خواهد قفل را
بگيرد ٬ یک بلیت اختصاص داده می شود. مقدار هر بلیت جدید یکی بیشتر از مقدار آخرین بلیت داده شده به پردازه ها است. قفل
در هر زمان دارای مقدار بلیتی است که باید به آن سرویس دهد. پردازه ای که دارای بلیتی با آن مقدار است، می تواند قفل را بگيرد
و پس از رها کردن قفل، نوبت بلیت بعدی می شود. )این نوبت ها به ترتیب خواهند بود( در واقع قفل بلیت نوعی قفل عادلانه
starvationبوده و در نتیجه، ازFIFO، این است که به صورتspin lockاست و مزیت اصلی استفاده از قفل بلیت در مقایسه با
مربوط به قفل بلیت را پیاده سازی کنید.releaseTicketlockوacquireTicketlock،initTicketlockجلوگيری می کند. توابع
را ببینید و با کمک گرفتن از آن، قفلspinlockمی توانید پیاده سازی مربوط به spinlock.cوspinlock.hبا مراجعه به فایل های
، استفاده کنید تاinline assemblyبلیت را پیاده سازی کنید. در پیاده سازی برای اضافه کردن یک واحد به مقدار بلیت باید از
اضافه شود.(x86.hبه شکل اتمیک اجرا شود. ) کد مربوطه باید در فایل

را به سیستم عامل اضافه کنید. فراخوانی سیستمی نخست، قفلticketlockTestوticketlockInitدو فراخوانی سیستمی
را مقداردهی اولیه نموده و دومی توسط پردازه هایی به طور موازی از آن استفاده می نماید تا از صحت عملکرد آن اطمینان حاصل
شود. برنامه سطح کاربر باید چیزی مشابه برنامه زیر باشد.
Busy waiting١
Critical Section٢

#### ۶صفحه ٢از


#### ١. ٢ پیاده سازی قفل خوانندگان و نویسندگان ١ سوال اول

```
در برنامه بالا باید ١٠ باشد.ticket lock valueمقدار
```
### ١. ٢ پیاده سازی قفل خوانندگان و نویسندگان

#### با استفاده از قفل بلیت، قفل خوانندگان‐نویسندگان را برای حالت تقدم خوانندگان پیاده سازی نمایید. برای این کار لازم است

را اضافه نمایید. ساختار توابع، مشابه توابع پیاده سازی شده برای قفلrwtest(uint pattern)وrwinitدو فراخوانی سیستمی
patternباید الگوی دسترسی به داده مشترک به صورت یک پارامتر صحیح مثبت به نامrwtestبلیت است. با این تفاوت که در
به هسته داده شود. به این شکل که سمت چپ ترین بیت همواره یک بوده و بیت های بعدی ترتیب زمانی خواندن یا نوشتن داده
مشترک را مشخص کنند. صفر معادل خواندن و یک معادل نوشتن خواهد بود. مثلا́ عدد ١٩ در فرم دودویی به صورت زیر نوشته
میشود : ١٠٠١١ با صرف نظر کردن از پرارزش ترین بیت، به ترتیب خواندن، خواندن، نوشتن و نوشتن رخ خواهد داد. به این ترتیب هر
پردازه در سطح هسته، متناسب با دسترسی مورد نظر، قفل خواندن یا نوشتن را درخواست می کند. در اینجا نیز می توان فرض نمود
که متغير مشترک یک عدد بوده که با هر بار نوشتن یک واحد به مقدار آن افزوده میشود.
برنامه سطح کاربر باید چیزی مشابه برنامه زیر باشد:

#### ۶صفحه ٣از


#### ١. ٢ پیاده سازی قفل خوانندگان و نویسندگان ١ سوال اول

#### برای هر قسمت از مراحل انجام کار و خروجی ها گزارش تهیه کنید.

#### ۶صفحه ۴از


#### ٢ سوال دوم: پیاده سازی ترد )THREAD( در سطح کرنل

## ٢ سوال دوم: پیاده سازی ترد )Thread( در سطح کرنل

### ٢. ١ مقدمات

#### این نوع ترد ها در سطح کرنل مدیریت می شوند و در برابر ترد های در سطح کاربر دارای مزایا و معایبی می باشند؛ این موارد را

structمشابه باstructدر گزارش خود ذکر کنید. هدف این سوال پیاده سازی این نوع ترد هاست. برای این منظور باید یک
می تواند چندین ترد داشته باشد کدام٣تعریف کنید و تصمیم بگيرید با توجه به این که هر پراسسstruct threadبه نامproc
بروند و در آنجا تعریف شوند؛ به عنوان مثال احتیاجیthreadباقی بمانند و کدام ها بهprocدرstruct procیک از فیلد های
به ساختن فضای مموری جدید برای هر ترد نخواهد بود.
استفاده شده است را بررسی کنید و جاهایی که لازمstruct procبرای شروع باید در تمامی کدها بخش هایی که از فیلدی از
جایگزین کنید. پس از انجام این کار هر پراسس در ابتدای شروع به کار خودstruct threadاست آن فیلدها را با متناظرشان از
MAX_THREADSیک ثابت به نامproc.hدارای یک ترد اصلی خواهد بود که در حال اجرا شدن می باشد. همچنين در فایل
با مقداری مثلا برابر با ١۶ انتخاب کنید و به واسطه ی آن به هر پراسس اجازه ندهید بیشتر از این تعداد ترد داشته باشد.
را طوری تغیير بدهید که بتواند از ترد هم در کنار پراسس پشتیبانی کند. همچنين تابعی مشابهstruct cpu بایدproc.hدر
استفاده شده استmyprocبرای دسترسی به ترد فعلی تعریف کنید و در هر جایی که ازmythread()به نامmyproc()با
را طوری تغیير دهید تاschedulerاستفاده بشود. همینطور لازم استmythreadتصمیم بگيرید که آیا لازم است به جای آن از
به جای اختصاص پردازنده به پراسس ها، به ترد ها پردازنده اختصاص بدهد. به این معنا که به هر ترد از یک پراسس، پردازنده
را اختصاص داده و سپس به سراغ پراسس بعدی برود.
باید به گونه ای اصلاح شود که در صورت اجرا شدن فقط ترد فراخوانی کننده ی آنforkتوجه کنید که سیستم کال فعلی
باید پراسس و تمامی تردexitدر پراسس جدید ایجاد شده وجود داشته باشد، نه ترد های دیگر آن پراسس. همینطور سیستم کال
های آن را خاتمه دهد؛ حتی اگر در زمان فراخوانی توسط یک ترد، ترد هایی دیگر از پراسس صاحب، در حال اجرا باشند.

### ٢. ٢ پیاده سازی سیستم کال ها

را پیاده سازی کنید که وظیفه ی ایجاد یک ترد برایint createThread(void (*function)() , void* stack)سیستم کال
برای ترد ساخته شدهuser stackیک پوینتر بهstackپراسسی که فراخوانی را انجام داده است بر عهده دارد. ورودی های آن
ساخته می شودcreateThreadکه توسط خودkernel stackبشود و باallocateاست که باید توسط پراسس فراخوانی کننده
یک پوینتر به تابعی است که ترد ایجاد شده وظیفه ی اجرای آن را برعهده دارد.functionتفاوت دارد. همچنين ورودی دیگر
می باشد.
